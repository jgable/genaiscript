{
  "javascript/tags": "(\n  (comment)* @doc\n  .\n  (method_definition\n    name: (property_identifier) @name) @definition.method\n  (#not-eq? @name \"constructor\")\n  (#strip! @doc \"^[\\\\s\\\\*/]+|^[\\\\s\\\\*/]$\")\n  (#select-adjacent! @doc @definition.method)\n)\n\n(\n  (comment)* @doc\n  .\n  [\n    (class\n      name: (_) @name)\n    (class_declaration\n      name: (_) @name)\n  ] @definition.class\n  (#strip! @doc \"^[\\\\s\\\\*/]+|^[\\\\s\\\\*/]$\")\n  (#select-adjacent! @doc @definition.class)\n)\n\n(\n  (comment)* @doc\n  .\n  [\n    (function_expression\n      name: (identifier) @name)\n    (function_declaration\n      name: (identifier) @name)\n    (generator_function\n      name: (identifier) @name)\n    (generator_function_declaration\n      name: (identifier) @name)\n  ] @definition.function\n  (#strip! @doc \"^[\\\\s\\\\*/]+|^[\\\\s\\\\*/]$\")\n  (#select-adjacent! @doc @definition.function)\n)\n\n(\n  (comment)* @doc\n  .\n  (lexical_declaration\n    (variable_declarator\n      name: (identifier) @name\n      value: [(arrow_function) (function_expression)]) @definition.function)\n  (#strip! @doc \"^[\\\\s\\\\*/]+|^[\\\\s\\\\*/]$\")\n  (#select-adjacent! @doc @definition.function)\n)\n\n(\n  (comment)* @doc\n  .\n  (variable_declaration\n    (variable_declarator\n      name: (identifier) @name\n      value: [(arrow_function) (function_expression)]) @definition.function)\n  (#strip! @doc \"^[\\\\s\\\\*/]+|^[\\\\s\\\\*/]$\")\n  (#select-adjacent! @doc @definition.function)\n)\n\n(assignment_expression\n  left: [\n    (identifier) @name\n    (member_expression\n      property: (property_identifier) @name)\n  ]\n  right: [(arrow_function) (function_expression)]\n) @definition.function\n\n(pair\n  key: (property_identifier) @name\n  value: [(arrow_function) (function_expression)]) @definition.function\n\n(\n  (call_expression\n    function: (identifier) @name) @reference.call\n  (#not-match? @name \"^(require)$\")\n)\n\n(call_expression\n  function: (member_expression\n    property: (property_identifier) @name)\n  arguments: (_) @reference.call)\n\n(new_expression\n  constructor: (_) @name) @reference.class\n\n(export_statement value: (assignment_expression left: (identifier) @name right: ([\n (number)\n (string)\n (identifier)\n (undefined)\n (null)\n (new_expression)\n (binary_expression)\n (call_expression)\n]))) @definition.constant\n",
  "c/tags": "(struct_specifier name: (type_identifier) @name body:(_)) @definition.class\n\n(declaration type: (union_specifier name: (type_identifier) @name)) @definition.class\n\n(function_declarator declarator: (identifier) @name) @definition.function\n\n(type_definition declarator: (type_identifier) @name) @definition.type\n\n(enum_specifier name: (type_identifier) @name) @definition.type\n",
  "cpp/tags": "(struct_specifier name: (type_identifier) @name body:(_)) @definition.class\n\n(declaration type: (union_specifier name: (type_identifier) @name)) @definition.class\n\n(function_declarator declarator: (identifier) @name) @definition.function\n\n(function_declarator declarator: (field_identifier) @name) @definition.function\n\n(function_declarator declarator: (qualified_identifier scope: (namespace_identifier) @local.scope name: (identifier) @name)) @definition.method\n\n(type_definition declarator: (type_identifier) @name) @definition.type\n\n(enum_specifier name: (type_identifier) @name) @definition.type\n\n(class_specifier name: (type_identifier) @name) @definition.class\n",
  "ruby/tags": "; Method definitions\n\n(\n  (comment)* @doc\n  .\n  [\n    (method\n      name: (_) @name) @definition.method\n    (singleton_method\n      name: (_) @name) @definition.method\n  ]\n  (#strip! @doc \"^#\\\\s*\")\n  (#select-adjacent! @doc @definition.method)\n)\n\n(alias\n  name: (_) @name) @definition.method\n\n(setter\n  (identifier) @ignore)\n\n; Class definitions\n\n(\n  (comment)* @doc\n  .\n  [\n    (class\n      name: [\n        (constant) @name\n        (scope_resolution\n          name: (_) @name)\n      ]) @definition.class\n    (singleton_class\n      value: [\n        (constant) @name\n        (scope_resolution\n          name: (_) @name)\n      ]) @definition.class\n  ]\n  (#strip! @doc \"^#\\\\s*\")\n  (#select-adjacent! @doc @definition.class)\n)\n\n; Module definitions\n\n(\n  (module\n    name: [\n      (constant) @name\n      (scope_resolution\n        name: (_) @name)\n    ]) @definition.module\n)\n\n; Calls\n\n(call method: (identifier) @name) @reference.call\n\n(\n  [(identifier) (constant)] @name @reference.call\n  (#is-not? local)\n  (#not-match? @name \"^(lambda|load|require|require_relative|__FILE__|__LINE__)$\")\n)\n",
  "go/tags": "(\n  (comment)* @doc\n  .\n  (function_declaration\n    name: (identifier) @name) @definition.function\n  (#strip! @doc \"^//\\\\s*\")\n  (#set-adjacent! @doc @definition.function)\n)\n\n(\n  (comment)* @doc\n  .\n  (method_declaration\n    name: (field_identifier) @name) @definition.method\n  (#strip! @doc \"^//\\\\s*\")\n  (#set-adjacent! @doc @definition.method)\n)\n\n(call_expression\n  function: [\n    (identifier) @name\n    (parenthesized_expression (identifier) @name)\n    (selector_expression field: (field_identifier) @name)\n    (parenthesized_expression (selector_expression field: (field_identifier) @name))\n  ]) @reference.call\n\n(type_spec\n  name: (type_identifier) @name) @definition.type\n\n(type_identifier) @name @reference.type\n",
  "c-sharp/tags": "(class_declaration name: (identifier) @name) @definition.class\n\n(class_declaration (base_list (_) @name)) @reference.class\n\n(interface_declaration name: (identifier) @name) @definition.interface\n\n(interface_declaration (base_list (_) @name)) @reference.interface\n\n(method_declaration name: (identifier) @name) @definition.method\n\n(object_creation_expression type: (identifier) @name) @reference.class\n\n(type_parameter_constraints_clause (identifier) @name) @reference.class\n\n(type_parameter_constraint (type type: (identifier) @name)) @reference.class\n\n(variable_declaration type: (identifier) @name) @reference.class\n\n(invocation_expression function: (member_access_expression name: (identifier) @name)) @reference.send\n\n(namespace_declaration name: (identifier) @name) @definition.module\n\n(namespace_declaration name: (identifier) @name) @module\n",
  "python/tags": "(module (expression_statement (assignment left: (identifier) @name) @definition.constant))\n\n(class_definition\n  name: (identifier) @name) @definition.class\n\n(function_definition\n  name: (identifier) @name) @definition.function\n\n(call\n  function: [\n      (identifier) @name\n      (attribute\n        attribute: (identifier) @name)\n  ]) @reference.call\n",
  "typescript/tags": "(function_signature\n  name: (identifier) @name) @definition.function\n\n(method_signature\n  name: (property_identifier) @name) @definition.method\n\n(abstract_method_signature\n  name: (property_identifier) @name) @definition.method\n\n(abstract_class_declaration\n  name: (type_identifier) @name) @definition.class\n\n(module\n  name: (identifier) @name) @definition.module\n\n(interface_declaration\n  name: (type_identifier) @name) @definition.interface\n\n(type_annotation\n  (type_identifier) @name) @reference.type\n\n(new_expression\n  constructor: (identifier) @name) @reference.class\n",
  "rust/tags": "; ADT definitions\n\n(struct_item\n    name: (type_identifier) @name) @definition.class\n\n(enum_item\n    name: (type_identifier) @name) @definition.class\n\n(union_item\n    name: (type_identifier) @name) @definition.class\n\n; type aliases\n\n(type_item\n    name: (type_identifier) @name) @definition.class\n\n; method definitions\n\n(declaration_list\n    (function_item\n        name: (identifier) @name)) @definition.method\n\n; function definitions\n\n(function_item\n    name: (identifier) @name) @definition.function\n\n; trait definitions\n(trait_item\n    name: (type_identifier) @name) @definition.interface\n\n; module definitions\n(mod_item\n    name: (identifier) @name) @definition.module\n\n; macro definitions\n\n(macro_definition\n    name: (identifier) @name) @definition.macro\n\n; references\n\n(call_expression\n    function: (identifier) @name) @reference.call\n\n(call_expression\n    function: (field_expression\n        field: (field_identifier) @name)) @reference.call\n\n(macro_invocation\n    macro: (identifier) @name) @reference.call\n\n; implementations\n\n(impl_item\n    trait: (type_identifier) @name) @reference.implementation\n\n(impl_item\n    type: (type_identifier) @name\n    !trait) @reference.implementation\n",
  "php/tags": "(namespace_definition\n  name: (namespace_name) @name) @module\n\n(interface_declaration\n  name: (name) @name) @definition.interface\n\n(trait_declaration\n  name: (name) @name) @definition.interface\n\n(class_declaration\n  name: (name) @name) @definition.class\n\n(class_interface_clause [(name) (qualified_name)] @name) @impl\n\n(property_declaration\n  (property_element (variable_name (name) @name))) @definition.field\n\n(function_definition\n  name: (name) @name) @definition.function\n\n(method_declaration\n  name: (name) @name) @definition.function\n\n(object_creation_expression\n  [\n    (qualified_name (name) @name)\n    (variable_name (name) @name)\n  ]) @reference.class\n\n(function_call_expression\n  function: [\n    (qualified_name (name) @name)\n    (variable_name (name)) @name\n  ]) @reference.call\n\n(scoped_call_expression\n  name: (name) @name) @reference.call\n\n(member_call_expression\n  name: (name) @name) @reference.call\n",
  "java/tags": "(class_declaration\n  name: (identifier) @name) @definition.class\n\n(method_declaration\n  name: (identifier) @name) @definition.method\n\n(method_invocation\n  name: (identifier) @name\n  arguments: (argument_list) @reference.call)\n\n(interface_declaration\n  name: (identifier) @name) @definition.interface\n\n(type_list\n  (type_identifier) @name) @reference.implementation\n\n(object_creation_expression\n  type: (type_identifier) @name) @reference.class\n\n(superclass (type_identifier) @name) @reference.class\n",
  "ocaml/tags": "; Modules\n;--------\n\n(\n  (comment)? @doc .\n  (module_definition (module_binding (module_name) @name) @definition.module)\n  (#strip! @doc \"^\\\\(\\\\*\\\\*?\\\\s*|\\\\s\\\\*\\\\)$\")\n)\n\n(module_path (module_name) @name) @reference.module\n\n; Module types\n;--------------\n\n(\n  (comment)? @doc .\n  (module_type_definition (module_type_name) @name) @definition.interface\n  (#strip! @doc \"^\\\\(\\\\*\\\\*?\\\\s*|\\\\s\\\\*\\\\)$\")\n)\n\n(module_type_path (module_type_name) @name) @reference.implementation\n\n; Functions\n;----------\n\n(\n  (comment)? @doc .\n  (value_definition\n    [\n      (let_binding\n        pattern: (value_name) @name\n        (parameter))\n      (let_binding\n        pattern: (value_name) @name\n        body: [(fun_expression) (function_expression)])\n    ] @definition.function\n  )\n  (#strip! @doc \"^\\\\(\\\\*\\\\*?\\\\s*|\\\\s\\\\*\\\\)$\")\n)\n\n(\n  (comment)? @doc .\n  (external (value_name) @name) @definition.function\n  (#strip! @doc \"^\\\\(\\\\*\\\\*?\\\\s*|\\\\s\\\\*\\\\)$\")\n)\n\n(application_expression\n  function: (value_path (value_name) @name)) @reference.call\n\n(infix_expression\n  left: (value_path (value_name) @name)\n  operator: (concat_operator) @reference.call\n  (#eq? @reference.call \"@@\"))\n\n(infix_expression\n  operator: (rel_operator) @reference.call\n  right: (value_path (value_name) @name)\n  (#eq? @reference.call \"|>\"))\n\n; Operator\n;---------\n\n(\n  (comment)? @doc .\n  (value_definition\n    (let_binding\n      pattern: (parenthesized_operator (_) @name)) @definition.function)\n  (#strip! @doc \"^\\\\(\\\\*\\\\*?\\\\s*|\\\\s\\\\*\\\\)$\")\n)\n\n[\n  (prefix_operator)\n  (sign_operator)\n  (pow_operator)\n  (mult_operator)\n  (add_operator)\n  (concat_operator)\n  (rel_operator)\n  (and_operator)\n  (or_operator)\n  (assign_operator)\n  (hash_operator)\n  (indexing_operator)\n  (let_operator)\n  (let_and_operator)\n  (match_operator)\n] @name @reference.call\n\n; Classes\n;--------\n\n(\n  (comment)? @doc .\n  [\n    (class_definition (class_binding (class_name) @name) @definition.class)\n    (class_type_definition (class_type_binding (class_type_name) @name) @definition.class)\n  ]\n  (#strip! @doc \"^\\\\(\\\\*\\\\*?\\\\s*|\\\\s\\\\*\\\\)$\")\n)\n\n[\n  (class_path (class_name) @name)\n  (class_type_path (class_type_name) @name)\n] @reference.class\n\n; Methods\n;--------\n\n(\n  (comment)? @doc .\n  (method_definition (method_name) @name) @definition.method\n  (#strip! @doc \"^\\\\(\\\\*\\\\*?\\\\s*|\\\\s\\\\*\\\\)$\")\n)\n\n(method_invocation (method_name) @name) @reference.call\n"
}